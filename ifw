#!/bin/bash
#
# ing's firewall
# Linux/Netfilter firewall script
#
# (c) 2003-2009 by ing at wild dot in dot ua
#
# Distributed under the terms of GNU GPLv3
#

FW="/etc/firewall"
INTERFACES="$FW/if"
TARPIT="$FW/tarpit"
TPORTS="$FW/tports"
BLACKMAC="$FW/blackmac"
BLACKLIST="$FW/blacklist"
HARDLIST="$FW/hardlist"
SOFTLIST="$FW/softlist"
WHITELIST="$FW/whitelist"
DNAT="$FW/dnat"
ETHER="$FW/ethers"
OPEN="$FW/open"
PASS="$FW/pass"
NOPASS="$FW/nopass"
LOG="$FW/log"
ULOG="$FW/ulog"
NOULOG="$FW/noulog"
MPORTS="$FW/mports"
PEERS="$FW/peers"
PPORTS="$FW/pports"

DATE=`date '+%Y%m%d%H%M%S'`
DUMPFILE="/var/log/iptables.dump"

if [ "$2" == "debug" ]; then
  IPT="echo iptables"
else
  IPT="iptables"
fi

if [ -r $LOG ]; then
  log=1
else
  log=0
fi

# convert config file with ports list
# to string accepted by multiport module
mp() {

  MP_TCP=
  MP_UDP=
  if [ -r $F ]; then
    for str in `cat $F`; do
      PORT=`expr "$str" : '\(.*\)\/'`
      PROTO=`expr "$str" : '.*\/\(.*\)'`
      case "$PROTO" in
      'tcp')
        if [ -z "$MP_TCP" ]; then
          MP_TCP="$PORT"
        else
          MP_TCP="$MP_TCP,$PORT"
        fi
        ;;
      'udp')
        if [ -z "$MP_UDP" ]; then
          MP_UDP="$PORT"
        else
          MP_UDP="$MP_UDP,$PORT"
        fi
        ;;
      '')
        echo "Empty protocol in $F." >&2
        exit 1
        ;;
      *)
        echo "Unknown protocol \"$PROTO\" in $F." >&2
        exit 1
        ;;
      esac
    done
  fi

}

firewall_start() {

  # filter table

  # interfaces
  if [ -r $INTERFACES ]; then
    flag=0
    for str in `cat $INTERFACES`; do
      if [ $flag == 0 ]; then
        IF=$str
        flag=1
      else
        TYPE=$str
        if [ -n "$IF" ] && [ -n "$TYPE" ]; then
          case "$TYPE" in
          "ext")
            IF_EXT[${#IF_EXT[@]}+1]=$IF
            ;;
          "int")
            IF_INT[${#IF_INT[@]}+1]=$IF
            ;;
          "masq")
            IF_MASQ[${#IF_MASQ[@]}+1]=$IF
            ;;
          "blind")
            IF_BLIND[${#IF_BLIND[@]}+1]=$IF
            ;;
          *)
            echo "Unknown type \"$TYPE\" for interface \"$IF\"." >&2
            exit 1
            ;;
          esac
        fi
        flag=0
      fi
    done
  else
    echo "Can not open config file: $INTERFACES"
    exit 1
  fi
  if [ ${#IF_EXT[@]} -lt 1 ] && [ ${#IF_INT[@]} -lt 1 ]; then
    echo "No external or internal interfaces found. Check $INTERFACES"
    exit 1
  fi

  # default policy is to drop everything
  $IPT -P INPUT DROP
  $IPT -P OUTPUT DROP
  $IPT -P FORWARD DROP

  # what to do with denied packets
  CH1='DENY'
  $IPT -N $CH1
  $IPT -A $CH1 -p tcp -j REJECT --reject-with tcp-reset
  $IPT -A $CH1 -p udp -j REJECT --reject-with icmp-port-unreachable
  $IPT -A $CH1 -j DROP

  # sanity check, filter strange packets
  CH1='CHECK'
  $IPT -N $CH1
  [[ $log -ge 1 ]] && $IPT -A $CH1 -p tcp ! --syn -m state --state NEW -j LOG --log-prefix "$CH1: "
  #$IPT -A $CH1 -p tcp ! --syn -m state --state NEW -j DROP

  # known ICMP types accepted
  CH1='ICMP'
  $IPT -N $CH1
  $IPT -A $CH1 -p icmp --icmp-type echo-request -j ACCEPT
  $IPT -A $CH1 -p icmp --icmp-type echo-reply -j ACCEPT
  $IPT -A $CH1 -p icmp --icmp-type destination-unreachable -j ACCEPT
  $IPT -A $CH1 -p icmp --icmp-type time-exceeded -j ACCEPT
  [[ $log -ge 1 ]] && $IPT -A $CH1 -j LOG --log-prefix "$CH1: "
  $IPT -A $CH1 -j DROP

  # tarpit: catch connections to these ports
  if [ -r $TPORTS ]; then
  CH1='TPORTS'
  $IPT -N $CH1
    if [ -r $TPORTS ]; then
      F=$TPORTS mp
      $IPT -A $CH1 -p tcp -m multiport --dport $MP_TCP -j LOG --log-prefix "$CH1: "
      [[ -n "$MP_TCP" ]] && $IPT -A $CH1 -p tcp -m multiport --dport $MP_TCP -j TARPIT
      $IPT -A $CH1 -p udp -m multiport --dport $MP_TCP -j LOG --log-prefix "$CH1: "
      [[ -n "$MP_UDP" ]] && $IPT -A $CH1 -p udp -m multiport --dport $MP_UDP -j TARPIT
    fi
  fi

  # tarpit: catch connections from these hosts
  if [ -r $TARPIT ]; then
    CH1='CATCH'
    $IPT -N $CH1
    for CIDR in `cat $TARPIT`; do
      if [ -n $CIDR ]; then
        [[ $log -ge 1 ]] && $IPT -A $CH1 -s $CIDR -p tcp -j LOG --log-prefix "$CH1: "
        $IPT -A $CH1 -s $CIDR -p tcp -j TARPIT
      fi
    done
  fi

  # whitelist: hosts, allowed to connect and fowrard, overriding blacklist
  if [ -r $WHITELIST ]; then
    CH1='WHITELIST'
    $IPT -N $CH1
    for CIDR in `cat $WHITELIST`; do
      if [ -n $CIDR ]; then
        $IPT -A $CH1 -s $CIDR -j ACCEPT
        $IPT -A $CH1 -d $CIDR -j ACCEPT
      fi
    done
  fi

  # MAC based blacklist: hosts, not allowed to connect or forward
  if [ -r $BLACKMAC ]; then
    CH1='BLACKMAC'
    $IPT -N $CH1
    for MAC in `cat $BLACKMAC`; do
      if [ -n $MAC ]; then
        [[ $log -ge 1 ]] && $IPT -A $CH1 -m mac --mac-source $MAC -j LOG --log-prefix "$CH1: "
        $IPT -A $CH1 -m mac --mac-source $MAC -j DENY
      fi
    done
  fi

  # IP based blacklist: hosts, not allowed to connect or forward
  if [ -r $BLACKLIST ]; then
    CH1='BLACKLIST'
    $IPT -N $CH1
    for CIDR in `cat $BLACKLIST`; do
      if [ -n $CIDR ]; then
        [[ $log -ge 1 ]] && $IPT -A $CH1 -s $CIDR -j LOG --log-prefix "$CH1: "
        $IPT -A $CH1 -s $CIDR -j DENY
      fi
    done
  fi

  # hardlist: hosts, not allowed to forward
  if [ -r $HARDLIST ]; then
    CH1='HARDLIST'
    $IPT -N $CH1
    for CIDR in `cat $HARDLIST`; do
      if [ -n $CIDR ]; then
        [[ $log -ge 1 ]] && $IPT -A $CH1 -s $CIDR -j LOG --log-prefix "$CH1: "
        $IPT -A $CH1 -s $CIDR -j DENY
        [[ $log -ge 1 ]] && $IPT -A $CH1 -d $CIDR -j LOG --log-prefix "$CH1: "
        $IPT -A $CH1 -d $CIDR -j DENY
      fi
    done
  fi

  # only accept packets from known MAC+IP pairs
  if [ -r $ETHER ]; then
    CH1='ETHER'
    $IPT -N $CH1
    # allow DHCP
    $IPT -A $CH1 -p udp --dport 67:68 --sport 67:68 -j ACCEPT
    flag=0
    for str in `cat $ETHER`; do
      if [ $flag == 0 ]; then
        MAC=$str
        flag=1
      else
        IP=$str
        if [ -n $MAC ] && [ -n $IP ]; then
          $IPT -A $CH1 -m mac --mac-source $MAC -s $IP -j RETURN
        fi
        flag=0
      fi
    done
    [[ $log -ge 1 ]] && $IPT -A $CH1 -j LOG --log-prefix "$CH1: "
    $IPT -A $CH1 -j DENY
  fi

  # packet counter
  if [ -r $ULOG ]; then

    # incoming packets counter
    CH1='ULOG_IN'
    $IPT -N $CH1

    # do not count packets from hosts-exceptions
    if [ -r $NOULOG ]; then
      for CIDR in `cat $NOULOG`; do
        [[ -n $CIDR ]] && $IPT -A $CH1 -s $CIDR -j RETURN
      done
    fi

    # count these packets as incoming
    $IPT -A $CH1 -j ULOG --ulog-nlgroup 10 --ulog-cprange 20 --ulog-qthreshold 20

    # outgoing packets counter
    CH1='ULOG_OUT'
    $IPT -N $CH1

    # do not count packets to hosts-exceptions
    if [ -r $NOULOG ]; then
      for CIDR in `cat $NOULOG`; do
        [[ -n $CIDR ]] && $IPT -A $CH1 -d $CIDR -j RETURN
      done
    fi

    # count these packets as outgoing
    $IPT -A $CH1 -j ULOG --ulog-nlgroup 20 --ulog-cprange 20 --ulog-qthreshold 20

  fi

  # allow inbound ports from some peers
  if [ -r $PEERS ]; then
    CH1='PEERS_IN'
    $IPT -N $CH1
    F=$PPORTS mp
    for CIDR in `cat $PEERS`; do
      if [ -n $CIDR ]; then
        [[ -n "$MP_TCP" ]] && $IPT -A $CH1 -s $CIDR -p tcp -m multiport --dport $MP_TCP -j RETURN
        [[ -n "$MP_UDP" ]] && $IPT -A $CH1 -s $CIDR -p udp -m multiport --dport $MP_UDP -j RETURN
      fi
    done
    [[ -n "$MP_TCP" ]] && [[ $log -ge 1 ]] && $IPT -A $CH1 -p tcp -m multiport --dport $MP_TCP -j LOG --log-prefix "$CH1: "
    [[ -n "$MP_TCP" ]] && $IPT -A $CH1 -p tcp -m multiport --dport $MP_TCP -j DENY
    [[ -n "$MP_UDP" ]] && [[ $log -ge 1 ]] && $IPT -A $CH1 -p udp -m multiport --dport $MP_UDP -j LOG --log-prefix "$CH1: "
    [[ -n "$MP_UDP" ]] && $IPT -A $CH1 -p udp -m multiport --dport $MP_UDP -j DENY
  fi

  # allow outbound ports to some peers
  if [ -r $PEERS ]; then
    CH1='PEERS_OUT'
    $IPT -N $CH1
    for CIDR in `cat $PEERS`; do
      if [ -n $CIDR ]; then
        [[ -n "$MP_TCP" ]] && $IPT -A $CH1 -d $CIDR -p tcp -m multiport --sport $MP_TCP -j RETURN
        [[ -n "$MP_UDP" ]] && $IPT -A $CH1 -d $CIDR -p udp -m multiport --sport $MP_UDP -j RETURN
      fi
    done
    [[ -n "$MP_TCP" ]] && [[ $log -ge 1 ]] && $IPT -A $CH1 -p tcp -m multiport --sport $MP_TCP -j LOG --log-prefix "$CH1: "
    [[ -n "$MP_TCP" ]] && $IPT -A $CH1 -p tcp -m multiport --sport $MP_TCP -j DENY
    [[ -n "$MP_UDP" ]] && [[ $log -ge 1 ]] && $IPT -A $CH1 -p udp -m multiport --sport $MP_UDP -j LOG --log-prefix "$CH1: "
    [[ -n "$MP_UDP" ]] && $IPT -A $CH1 -p udp -m multiport --sport $MP_UDP -j DENY
  fi

  # input chain, always exists
  CH1='INPUT'

  # accept all loopback packets
  $IPT -A $CH1 -i lo -j ACCEPT

  # sanity check first
  $IPT -A $CH1 -j CHECK

  # catch connections to theses ports
  [[ -r $TPORTS ]] && $IPT -A $CH1 -j TPORTS

  # catch connections from theses hosts
  [[ -r $TARPIT ]] && $IPT -A $CH1 -j CATCH

  # allow pockects from whitelisted hosts
  [[ -r $WHITELIST ]] && $IPT -A $CH1 -j WHITELIST

  # deny pockects from blacklisted hosts
  [[ -r $BLACKMAC ]] && $IPT -A $CH1 -j BLACKMAC
  [[ -r $BLACKLIST ]] && $IPT -A $CH1 -j BLACKLIST

  # separate chain for each internal interface
  for IF in ${IF_INT[@]}; do
    CH2=$CH1\_$IF
    $IPT -N $CH2

    # deny trffic from unknown MAC+IP pairs
    [[ -r $ETHER ]] && $IPT -A $CH2 -j ETHER

    # accept all the other
    $IPT -A $CH2 -j ACCEPT

    # hook to upper chain
    $IPT -A $CH1 -i $IF -j $CH2

  done

  # separate chain for each external interface
  for IF in ${IF_EXT[@]}; do
    CH2=$CH1\_$IF
    $IPT -N $CH2

    # count all incoming packets
    [[ -r $ULOG ]] && $IPT -A $CH2 -j ULOG_IN

    # accept established connections
    $IPT -A $CH2 -p tcp -m state --state ESTABLISHED,RELATED -j ACCEPT
    $IPT -A $CH2 -p udp -m state --state ESTABLISHED,RELATED -j ACCEPT

    # accept packets to open ports on this host
    if [ -r $OPEN ]; then
      F=$OPEN mp
      [[ -n "$MP_TCP" ]] && $IPT -A $CH2 -p tcp -m multiport --dport $MP_TCP -j ACCEPT
      [[ -n "$MP_UDP" ]] && $IPT -A $CH2 -p udp -m multiport --dport $MP_UDP -j ACCEPT
    fi

    # accept ICMP
    $IPT -A $CH2 -p icmp -j ICMP

    # allow inbound ports from some peers
    [[ -r $PEERS ]] && $IPT -A $CH1 -j PEERS_IN

    # deny all the rest on this interface
    [[ $log -ge 1 ]] && $IPT -A $CH2 -j LOG --log-prefix "$CH2: "
    $IPT -A $CH2 -j DENY

    # hook to upper chain
    $IPT -A $CH1 -i $IF -j $CH2

  done

  # deny all the rest
  [[ $log -ge 1 ]] && $IPT -A $CH1 -j LOG --log-prefix "$CH1: "
  $IPT -A $CH1 -j DENY

  # output chain, always exists
  CH1='OUTPUT'

  # accept all loopback packets
  $IPT -A $CH1 -o lo -j ACCEPT

  # allow packets to whitelisted hosts
  [[ -r $WHITELIST ]] && $IPT -A $CH1 -j WHITELIST

  # deny packets to blacklisted hosts
  [[ -r $BLACKMAC ]] && $IPT -A $CH1 -j BLACKMAC
  [[ -r $BLACKLIST ]] && $IPT -A $CH1 -j BLACKLIST

  # separate chain for each internal interface
  for IF in ${IF_INT[@]}; do
    CH2=$CH1\_$IF
    $IPT -N $CH2

    # accept all packets to internal hosts
    $IPT -A $CH2 -j ACCEPT

    # hook to upper chain
    $IPT -A $CH1 -o $IF -j $CH2

  done

  # separate chain for each external interface
  for IF in ${IF_EXT[@]}; do
    CH2=$CH1\_$IF
    $IPT -N $CH2

    # count all packets to external interfaces
    [[ -r $ULOG ]] && $IPT -A $CH2 -j ULOG_OUT

    # allow outbound ports to some peers
    [[ -r $PEERS ]] && $IPT -A $CH1 -j PEERS_OUT

    # accept all packets to external interfaces
    $IPT -A $CH2 -j ACCEPT

    # hook to upper chain
    $IPT -A $CH1 -o $IF -j $CH2

  done

  # deny all the other
  [[ $log -ge 1 ]] && $IPT -A $CH1 -j LOG --log-prefix "$CH1: "
  $IPT -A $CH1 -j DENY

  # forward chain, always exists
  CH1='FORWARD'

  # sanity check first
  $IPT -A $CH1 -j CHECK

  # allow packets from whitelisted hosts
  [[ -r $WHITELIST ]] && $IPT -A $CH1 -j WHITELIST

  # deny packets from blacklisted hosts
  [[ -r $BLACKMAC ]] && $IPT -A $CH1 -j BLACKMAC
  [[ -r $BLACKLIST ]] && $IPT -A $CH1 -j BLACKLIST

  # separate chain for each internal interface
  for IF in ${IF_INT[@]}; do
    CH2=$CH1\_$IF
    $IPT -N $CH2

    # pass packets only with valid source IP
    if [ -r $INTERFACES.$IF ]; then
      CH3=$CH2\_SIP
      $IPT -N $CH3
      for CIDR in `cat $INTERFACES.$IF`; do
        [[ -n $CIDR ]] && $IPT -A $CH3 -s $CIDR -j RETURN
      done
      [[ $log -ge 1 ]] && $IPT -A $CH3 -j LOG --log-prefix "$CH3: "
      $IPT -A $CH3 -j DENY
      $IPT -A $CH2 -j $CH3
    fi

    # don't forward packets from/to internal interfaces to/from blinded interfaces
    for IF_O in ${IF_INT[@]}; do
      for IF_B in ${IF_BLIND[@]}; do
        if ([ -n $IF_B ] && [ $IF != $IF_O ]) && ([ $IF == $IF_B ] || [ $IF_O == $IF_B ]); then
          [[ $log -ge 1 ]] && $IPT -A $CH2 -o $IF_O -j LOG --log-prefix "BLIND: "
          $IPT -A $CH2 -o $IF_O -j DENY
        fi
      done
    done

    # don't forward packets from hardlisted hosts
    [[ -r $HARDLIST ]] && $IPT -A $CH2 -j HARDLIST

    # don't forward packets from softlisted hosts on specified ports
    if [ -r $SOFTLIST ]; then
      IFS=$'\t\n'
      for CIDR in `cat $SOFTLIST`; do
        unset IFS
        if [ -r $NOPASS ]; then
          F=$NOPASS mp
          if [ -n "$MP_TCP" ]; then
            [[ $log -ge 1 ]] && $IPT -A $CH2 -s $CIDR -p tcp -m multiport --dport $MP_TCP -j LOG --log-prefix "SOFTLIST: "
            $IPT -A $CH2 -s $CIDR -p tcp -m multiport --dport $MP_TCP -j DENY
          fi
          if [ -n "$MP_UDP" ]; then
            [[ $log -ge 1 ]] && $IPT -A $CH2 -s $CIDR -p udp -m multiport --dport $MP_UDP -j LOG --log-prefix "SOFTLIST: "
            $IPT -A $CH2 -s $CIDR -p udp -m multiport --dport $MP_UDP -j DENY
          fi
        fi
      done
    fi

    # deny packets from unknown MAC+IP pairs
    [[ -r $ETHER ]] && $IPT -A $CH2 -j ETHER

    # count only packets, coming out from external interfaces
    for IF_O in ${IF_EXT[@]}; do
      [[ -r $ULOG ]] && $IPT -A $CH2 -o $IF_O -j ULOG_OUT
    done

    # accept all the other on this interface
    $IPT -A $CH2 -j ACCEPT
    $IPT -A $CH1 -i $IF -j $CH2

  done

  # separate chain for each interface
  for IF in ${IF_EXT[@]}; do
    CH2=$CH1\_$IF
    $IPT -N $CH2

    # count all packets
    [[ -r $ULOG ]] && $IPT -A $CH2 -j ULOG_IN

    # don't forward packets to hardlisted hosts
    [[ -r $HARDLIST ]] && $IPT -A $CH2 -j HARDLIST

    # don't forward packets to softlisted hosts on specified ports
    if [ -r $SOFTLIST ]; then
      IFS=$'\t\n'
      for CIDR in `cat $SOFTLIST`; do
        unset IFS
        if [ -r $NOPASS ]; then
          F=$NOPASS mp
          if [ -n "$MP_TCP" ]; then
            [[ $log -ge 1 ]] && $IPT -A $CH2 -d $CIDR -p tcp -m multiport --sport $MP_TCP -j LOG --log-prefix "SOFTLIST: "
            $IPT -A $CH2 -d $CIDR -p tcp -m multiport --sport $MP_TCP -j DENY
          fi
          if [ -n "$MP_UDP" ]; then
            [[ $log -ge 1 ]] && $IPT -A $CH2 -d $CIDR -p udp -m multiport --sport $MP_UDP -j LOG --log-prefix "SOFTLIST: "
            $IPT -A $CH2 -d $CIDR -p udp -m multiport --sport $MP_UDP -j DENY
          fi
        fi
      done
    fi

    # accept established connections
    $IPT -A $CH2 -p tcp -m state --state ESTABLISHED,RELATED -j ACCEPT
    $IPT -A $CH2 -p udp -m state --state ESTABLISHED,RELATED -j ACCEPT

    # accept packets to internal hosts on chosen ports
    F=$PASS mp
    [[ -n "$MP_TCP" ]] && $IPT -A $CH2 -p tcp -m multiport --dport $MP_TCP -j LOG --log-prefix "$CH2: "
    [[ -n "$MP_TCP" ]] && $IPT -A $CH2 -p tcp -m multiport --dport $MP_TCP -j ACCEPT
    [[ -n "$MP_UDP" ]] && $IPT -A $CH2 -p udp -m multiport --dport $MP_UDP -j LOG --log-prefix "$CH2: "
    [[ -n "$MP_UDP" ]] && $IPT -A $CH2 -p udp -m multiport --dport $MP_UDP -j ACCEPT

    # accept ICMP
    $IPT -A $CH2 -p icmp -j ICMP

    # deny all the other on this interface
    [[ $log -ge 1 ]] && $IPT -A $CH2 -j LOG --log-prefix "$CH2: "
    $IPT -A $CH2 -j DENY

    # hook to upper chain
    $IPT -A $CH1 -i $IF -j $CH2

  done

  # deny all the other
  [[ $log -ge 1 ]] && $IPT -A $CH1 -j LOG --log-prefix "$CH1: "
  $IPT -A $CH1 -j DENY

  # DNAT to internal hosts
  if [ -r $DNAT ]; then

    # prerouting chain, always exists
    CH1='PREROUTING'

    # only for external interfaces
    for IF in ${IF_EXT[@]}; do
      flag=0
      for str in `cat $DNAT`; do

        # parse two-column table in config file
        if [ $flag == 0 ]; then
          PORT=`expr "$str" : '\(.*\)\/'`
          PROTO=`expr "$str" : '.*\/\(.*\)'`
          flag=1
        else
          DST=$str
          if [ -n $PORT ] && [ -n $PROTO ] && [ -n $DST ]; then
            $IPT -t nat -A $CH1 -i $IF -p $PROTO --dport $PORT -j DNAT --to $DST
          fi
          flag=0
        fi

      done
    done

  fi

  # nat table

  # postrouting chain, always exists
  CH1='POSTROUTING'

  # masquerade on chosen interfaces
  for IF in ${IF_MASQ[@]}; do
    [[ -n $IF ]] && $IPT -t nat -A $CH1 -o $IF -j MASQUERADE
  done

  # mangle table

  # mangling for outgoing packets
  CH1='OUTPUT'
  
  if [ -r $MPORTS ]; then
    flag=0
    for str in `cat $MPORTS`; do

      # parse two-column table in config file
      if [ $flag == 0 ]; then
        PORT=`expr "$str" : '\(.*\)\/'`
        PROTO=`expr "$str" : '.*\/\(.*\)'`
        flag=1
      else
        MARK=$str
        if [ -n $PORT ] && [ -n $PROTO ] && [ -n $MARK ]; then
          $IPT -t mangle -A $CH1 -p $PROTO --sport $PORT -j MARK --set-mark $MARK
          $IPT -t mangle -A $CH1 -p $PROTO --dport $PORT -j MARK --set-mark $MARK
        fi
        flag=0
      fi

    done
  fi

  # mangling for forwarded packets
  CH1='PREROUTING'
  
  if [ -r $MPORTS ]; then
    flag=0
    for str in `cat $MPORTS`; do

      # parse two-column table in config file
      if [ $flag == 0 ]; then
        PORT=`expr "$str" : '\(.*\)\/'`
        PROTO=`expr "$str" : '.*\/\(.*\)'`
        flag=1
      else
        MARK=$str
        if [ -n $PORT ] && [ -n $PROTO ] && [ -n $MARK ]; then
          $IPT -t mangle -A $CH1 -p $PROTO --sport $PORT -j MARK --set-mark $MARK
          $IPT -t mangle -A $CH1 -p $PROTO --dport $PORT -j MARK --set-mark $MARK
        fi
        flag=0
      fi

    done
  fi

}

firewall_stop() {

  # flush, delete and zero all chains
  for t in filter nat mangle; do
    for op in F X Z; do
      $IPT -t $t -$op
    done
  done

  # default policy is to accept everything
  $IPT -P INPUT ACCEPT
  $IPT -P OUTPUT ACCEPT
  $IPT -P FORWARD ACCEPT

}

firewall_status() {

  # dump all counters
  echo "START $DATE"
  $IPT -t filter -vnx -L --line-numbers
  echo "END $DATE"

}

case "$1" in

  start)
    firewall_start
    ;;

  stop)
    firewall_stop
    ;;

  restart)
    firewall_stop
    firewall_start
    ;;

  status)
    firewall_status
    ;;

  dump)
    firewall_status >>$DUMPFILE
    ;;

  *)
    echo "usage: $0 {start|stop|restart|status|dump} [debug]" >&2
    exit 1
    ;;

esac

exit 0
