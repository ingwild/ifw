#!/bin/bash
#
# rc.firewall-0.25
# Linux/Netfilter firewall script.
#
# (c) 2004 by ingwar
# Distributed under the terms of GNU GPLv2 or later versions.
#

FW="/etc/firewall"
INTERFACES="$FW/if"
BLACKLIST="$FW/blacklist"
HARDLIST="$FW/hardlist"
SOFTLIST="$FW/softlist"
DNAT="$FW/dnat"
ETHER="$FW/ethers"
OPEN="$FW/open"
PASS="$FW/pass"
NOPASS="$FW/nopass"
LOG="$FW/log"
ULOG="$FW/ulog"
NOULOG="$FW/noulog"

DATE=`date '+%Y%m%d%H%M%S'`
DUMPFILE="/var/log/iptables.dump"

if [ "$2" == "debug" ]; then
  IPT="echo iptables"
else
  IPT="iptables"
fi

if [ -r $LOG ]; then
  log=1
else
  log=0
fi

# convert config file with ports list
# to string accepted by multiport module
mp() {

  MP_TCP=
  MP_UDP=
  if [ -r $F ]; then
    for str in `cat $F`; do
      PORT=`expr "$str" : '\(.*\)\/'`
      PROTO=`expr "$str" : '.*\/\(.*\)'`
      case "$PROTO" in
      'tcp')
        if [ -z "$MP_TCP" ]; then
          MP_TCP="$PORT"
        else
          MP_TCP="$MP_TCP,$PORT"
        fi
        ;;
      'udp')
        if [ -z "$MP_UDP" ]; then
          MP_UDP="$PORT"
        else
          MP_UDP="$MP_UDP,$PORT"
        fi
        ;;
      '')
        echo "Empty protocol in $INTERFACES." >&2
        exit 1
        ;;
      *)
        echo "Unknown protocol \"$PROTO\" in $INTERFACES." >&2
        exit 1
        ;;
      esac
    done
  fi

}

firewall_start() {

  # interfaces
  if [ -r $INTERFACES ]; then
    flag=0
    for str in `cat $INTERFACES`; do
      if [ $flag == 0 ]; then
        IF=$str
        flag=1
      else
        TYPE=$str
        if [ -n "$IF" ] && [ -n "$TYPE" ]; then
          case "$TYPE" in
          "ext")
            IF_EXT[${#IF_EXT[@]}+1]=$IF
            ;;
          "int")
            IF_INT[${#IF_INT[@]}+1]=$IF
            ;;
          "masq")
            IF_MASQ[${#IF_MASQ[@]}+1]=$IF
            ;;
          *)
            echo "Unknown type \"$TYPE\" for interface \"$IF\"." >&2
            exit 1
            ;;
          esac
        fi
        flag=0
      fi
    done
  else
    echo "Can not open config file: $INTERFACES"
    exit 1
  fi
  if [ ${#IF_EXT[@]} -lt 1 ] && [ ${#IF_INT[@]} -lt 1 ]; then
    echo "No external or internal interfaces found. Check $INTERFACES"
    exit 1
  fi

  # default policy is to drop everything
  $IPT -P INPUT DROP
  $IPT -P OUTPUT DROP
  $IPT -P FORWARD DROP

  # what to do with denied packets
  CH='DENY'
  $IPT -N $CH
  $IPT -A $CH -p tcp -j REJECT --reject-with tcp-reset
  $IPT -A $CH -p udp -j REJECT --reject-with icmp-port-unreachable
  $IPT -A $CH -j DROP

  # sanity check, filter strange packets
  CH='CHECK'
  $IPT -N $CH
  [[ $log -ge 1 ]] && $IPT -A $CH -p tcp ! --syn -m state --state NEW -j LOG --log-prefix "$CH: "
  $IPT -A $CH -p tcp ! --syn -m state --state NEW -j DROP

  # blacklist: hosts, not allowed to connect or forward
  if [ -r $BLACKLIST ]; then
    CH='BLACKLIST'
    $IPT -N $CH
    for CIDR in `cat $BLACKLIST`; do
      if [ -n "$CIDR" ]; then
        [[ $log -ge 1 ]] && $IPT -A $CH -s $CIDR -j LOG --log-prefix "$CH: "
        $IPT -A $CH -s $CIDR -j DENY
      fi
    done
  fi

  # hardlist: hosts, not allowed to forward
  if [ -r $HARDLIST ]; then
    CH='HARDLIST'
    $IPT -N $CH
    for CIDR in `cat $HARDLIST`; do
      if [ -n "$CIDR" ]; then
        [[ $log -ge 1 ]] && $IPT -A $CH -s $CIDR -j LOG --log-prefix "$CH: "
        $IPT -A $CH -s $CIDR -j DENY
        [[ $log -ge 1 ]] && $IPT -A $CH -d $CIDR -j LOG --log-prefix "$CH: "
        $IPT -A $CH -d $CIDR -j DENY
      fi
    done
  fi

  # only accept packets from known MAC+IP pairs
  if [ -r $ETHER ]; then
    CH='ETHER'
    $IPT -N $CH
    flag=0
    for str in `cat $ETHER`; do
      if [ $flag == 0 ]; then
        MAC=$str
        flag=1
      else
        IP=$str
        if [ -n "$MAC" ] && [ -n "$IP" ]; then
          $IPT -A $CH -m mac --mac-source $MAC -s $IP -j RETURN
        fi
        flag=0
      fi
    done
    [[ $log -ge 1 ]] && $IPT -A $CH -j LOG --log-prefix "$CH: "
    $IPT -A $CH -j DENY
  fi

  # packet counter
  if [ -r $ULOG ]; then

    # incoming packets counter
    CH='ULOG_IN'
    $IPT -N $CH

    # do not count packets from hosts-exceptions
    if [ -r $NOULOG ]; then
      for CIDR in `cat $NOULOG`; do
        [[ -n "$CIDR" ]] && $IPT -A $CH -s $CIDR -j RETURN
      done
    fi

    # count these packets as incoming
    $IPT -A $CH -j ULOG --ulog-nlgroup 10 --ulog-cprange 20 --ulog-qthreshold 20

    # outgoing packets counter
    CH='ULOG_OUT'
    $IPT -N $CH

    # do not count packets to hosts-exceptions
    if [ -r $NOULOG ]; then
      for CIDR in `cat $NOULOG`; do
        [[ -n "$CIDR" ]] && $IPT -A $CH -d $CIDR -j RETURN
      done
    fi

    # count these packets as outgoing
    $IPT -A $CH -j ULOG --ulog-nlgroup 20 --ulog-cprange 20 --ulog-qthreshold 20

  fi

  # input chain, always exists
  CH='INPUT'

  # accept all loopback packets
  $IPT -A $CH -i lo -j ACCEPT

  # sanity check first
  $IPT -A $CH -j CHECK

  # deny pockects from blacklisted hosts
  [[ -r $BLACKLIST ]] && $IPT -A $CH -j BLACKLIST

  # separate chain for each internal interface
  for IF in ${IF_INT[@]}; do
    $IPT -N "$CH"_"$IF"

    # deny trffic from unknown MAC+IP pairs
    [[ -r $ETHER ]] && $IPT -A "$CH"_"$IF" -j ETHER

    # accept all the other
    $IPT -A "$CH"_"$IF" -j ACCEPT

    # hook to upper chain
    $IPT -A $CH -i $IF -j "$CH"_"$IF"

  done

  # separate chain for each external interface
  for IF in ${IF_EXT[@]}; do
    $IPT -N "$CH"_"$IF"

    # count all incoming packets
    [[ -r $ULOG ]] && $IPT -A "$CH"_"$IF" -j ULOG_IN

    # accept established connections
    $IPT -A "$CH"_"$IF" -p tcp -m state --state ESTABLISHED,RELATED -j ACCEPT
    $IPT -A "$CH"_"$IF" -p udp -m state --state ESTABLISHED,RELATED -j ACCEPT

    # accept packets to open ports on this host
    if [ -r $OPEN ]; then
      F=$OPEN mp
      [[ -n "$MP_TCP" ]] && $IPT -A "$CH"_"$IF" -p tcp -m multiport --dport $MP_TCP -j ACCEPT
      [[ -n "$MP_UDP" ]] && $IPT -A "$CH"_"$IF" -p udp -m multiport --dport $MP_UDP -j ACCEPT
    fi

    # accept ICMP
    $IPT -A "$CH"_"$IF" -p icmp -j ACCEPT

    # deny all the rest on this interface
    [[ $log -ge 1 ]] && $IPT -A "$CH"_"$IF" -j LOG --log-prefix "$CH"_"$IF: "
    $IPT -A "$CH"_"$IF" -j DENY

    # hook to upper chain
    $IPT -A "$CH" -i $IF -j "$CH"_"$IF"

  done

  # deny all the rest
  [[ $log -ge 1 ]] && $IPT -A $CH -j LOG --log-prefix "$CH: "
  $IPT -A $CH -j DENY

  # output chain, always exists
  CH='OUTPUT'

  # accept all loopback packets
  $IPT -A $CH -o lo -j ACCEPT

  # deny packets to blacklisted hosts
  [[ -r $BLACKLIST ]] && $IPT -A $CH -j BLACKLIST

  # separate chain for each internal interface
  for IF in ${IF_INT[@]}; do
    $IPT -N "$CH"_"$IF"

    # accept all packets to internal hosts
    $IPT -A "$CH"_"$IF" -j ACCEPT

    # hook to upper chain
    $IPT -A $CH -o $IF -j "$CH"_"$IF"

  done

  # separate chain for each external interface
  for IF in ${IF_EXT[@]}; do
    $IPT -N "$CH"_"$IF"

    # count all packets to external interfaces
    [[ -r $ULOG ]] && $IPT -A "$CH"_"$IF" -j ULOG_OUT

    # accept all packets to external interfaces
    $IPT -A "$CH"_"$IF" -j ACCEPT

    # hook to upper chain
    $IPT -A $CH -o $IF -j "$CH"_"$IF"

  done

  # deny all the other
  [[ $log -ge 1 ]] && $IPT -A $CH -j LOG --log-prefix "$CH: "
  $IPT -A $CH -j DENY

  # forward chain, always exists
  CH='FORWARD'

  # sanity check first
  $IPT -A $CH -j CHECK

  # deny packets from blacklisted hosts
  [[ -r $BLACKLIST ]] && $IPT -A $CH -j BLACKLIST

  # separate chain for each internal interface
  for IF in ${IF_INT[@]}; do
    $IPT -N "$CH"_"$IF"

    # don't forward packets from hardlisted hosts
    [[ -r $HARDLIST ]] && $IPT -A "$CH"_"$IF" -j HARDLIST

    # don't forward packets from softlisted hosts on specified ports
    if [ -r $SOFTLIST ]; then
      for CIDR in `cat $SOFTLIST`; do
        if [ -r $NOPASS ]; then
          F=$NOPASS mp
          if [ -n "$MP_TCP" ]; then
            [[ $log -ge 1 ]] && $IPT -A "$CH"_"$IF" -s $CIDR -p tcp -m multiport --dport $MP_TCP -j LOG --log-prefix "SOFTLIST: "
            $IPT -A "$CH"_"$IF" -s $CIDR -p tcp -m multiport --dport $MP_TCP -j DENY
          fi
          if [ -n "$MP_UDP" ]; then
            [[ $log -ge 1 ]] && $IPT -A "$CH"_"$IF" -s $CIDR -p udp -m multiport --dport $MP_UDP -j LOG --log-prefix "SOFTLIST: "
            $IPT -A "$CH"_"$IF" -s $CIDR -p udp -m multiport --dport $MP_UDP -j DENY
          fi
        fi
      done
    fi

    # deny packets from unknown MAC+IP pairs
    [[ -r $ETHER ]] && $IPT -A "$CH"_"$IF" -j ETHER

    # count only packets, coming out from external interfaces
    for IF_O in ${IF_EXT[@]}; do
      [[ -r $ULOG ]] && $IPT -A "$CH"_"$IF" -o $IF_O -j ULOG_OUT
    done

    # accept all the other on this interface
    $IPT -A "$CH"_"$IF" -j ACCEPT
    $IPT -A "$CH" -i $IF -j "$CH"_"$IF"

  done

  # separate chain for each interface
  for IF in ${IF_EXT[@]}; do
    $IPT -N "$CH"_"$IF"

    # count all packets
    [[ -r $ULOG ]] && $IPT -A "$CH"_"$IF" -j ULOG_IN

    # don't forward packets to hardlisted hosts
    [[ -r $HARDLIST ]] && $IPT -A "$CH"_"$IF" -j HARDLIST

    # don't forward packets to softlisted hosts on specified ports
    if [ -r $SOFTLIST ]; then
      for CIDR in `cat $SOFTLIST`; do
        if [ -r $NOPASS ]; then
          F=$NOPASS mp
          if [ -n "$MP_TCP" ]; then
            [[ $log -ge 1 ]] && $IPT -A "$CH"_"$IF" -d $CIDR -p tcp -m multiport --sport $MP_TCP -j LOG --log-prefix "SOFTLIST: "
            $IPT -A "$CH"_"$IF" -d $CIDR -p tcp -m multiport --sport $MP_TCP -j DENY
          fi
          if [ -n "$MP_UDP" ]; then
            [[ $log -ge 1 ]] && $IPT -A "$CH"_"$IF" -d $CIDR -p udp -m multiport --sport $MP_UDP -j LOG --log-prefix "SOFTLIST: "
            $IPT -A "$CH"_"$IF" -d $CIDR -p udp -m multiport --sport $MP_UDP -j DENY
          fi
        fi
      done
    fi

    # accept established connections
    $IPT -A "$CH"_"$IF" -p tcp -m state --state ESTABLISHED,RELATED -j ACCEPT
    $IPT -A "$CH"_"$IF" -p udp -m state --state ESTABLISHED,RELATED -j ACCEPT

    # accept packets to internal hosts on chosen ports
    F=$PASS mp
    [[ -n "$MP_TCP" ]] && $IPT -A "$CH"_"$IF" -p tcp -m multiport --dport $MP_TCP -j ACCEPT
    [[ -n "$MP_UDP" ]] && $IPT -A "$CH"_"$IF" -p udp -m multiport --dport $MP_UDP -j ACCEPT

    # accept ICMP
    $IPT -A "$CH"_"$IF" -p icmp -j ACCEPT

    # deny all the other on this interface
    [[ $log -ge 1 ]] && $IPT -A "$CH"_"$IF" -j LOG --log-prefix "$CH"_"$IF: "
    $IPT -A "$CH"_"$IF" -j DENY

    # hook to upper chain
    $IPT -A "$CH" -i $IF -j "$CH"_"$IF"

  done

  # deny all the other
  [[ $log -ge 1 ]] && $IPT -A "$CH" -j LOG --log-prefix "$CH: "
  $IPT -A "$CH" -j DENY

  # DNAT to internal hosts
  if [ -r "$DNAT" ]; then

    # prerouting chain, always exists
    CH='PREROUTING'

    # only for external interfaces
    for IF in ${IF_EXT[@]}; do
      flag=0
      for str in `cat $DNAT`; do

        # parse two-column table in config file
        if [ $flag == 0 ]; then
          PORT=`expr "$str" : '\(.*\)\/'`
          PROTO=`expr "$str" : '.*\/\(.*\)'`
          flag=1
        else
          DST=$str
          if [ -n "$PORT" ] && [ -n "$PROTO" ] && [ -n "$DST" ]; then
            $IPT -t nat -A $CH -i $IF -p $PROTO --dport $PORT -j DNAT --to $DST
          fi
          flag=0
        fi

      done
    done

  fi

  # postrouting chain, always exists
  CH='POSTROUTING'

  # masquerade on chosen interfaces
  for IF in ${IF_MASQ[@]}; do
    [[ -n "$IF" ]] && $IPT -t nat -A "$CH" -o $IF -j MASQUERADE
  done

}

firewall_stop() {

  # flush, delete and zero all chains
  for t in filter nat mangle; do
    for op in F X Z; do
      $IPT -t $t -$op
    done
  done

  # default policy is to accept everything
  $IPT -P INPUT ACCEPT
  $IPT -P OUTPUT ACCEPT
  $IPT -P FORWARD ACCEPT

}

firewall_status() {

  # dump all counters
  echo "START $DATE"
  $IPT -t filter -vnx -L --line-numbers
  echo "END $DATE"

}

case "$1" in

  start)
    firewall_start
    ;;

  stop)
    firewall_stop
    ;;

  restart)
    firewall_stop
    firewall_start
    ;;

  status)
    firewall_status
    ;;

  dump)
    firewall_status >>$DUMPFILE
    ;;

  *)
    echo "usage: $0 {start|stop|restart|status|dump} [debug]" >&2
    exit 1
    ;;

esac

exit 0
